# Python

## 1. Интерпретатор и компилятор

Среди высокоуровневых языков программирования есть интерпретируемые и компилируемые языки программирования.

*P. s.* На самом деле еще есть так называемый смешанный тип - байткод-языки, но о них позже.

Компилируемые языки имеют встроенный **компилятор**. Данные компиляторы переводят весь написанный код-текст в машинный код - код, понятный процессору. Процессор читает полученный код и исполняет его. Компиляция проходит один раз и целиком.

Интерпретируемые языки имеют встроенный **интерпретатор**. Интерпретатор самостоятельно **построчно** переводит код в понятный для себя формат и исполняет его.

## 2. Интерпретатор и виртуальное окружение

*P. s.* Пишется касательно высокоуровневого языка программирования Python, но может касаться и других языков, например, Java.

Все необходимые библиотеки можно установить через pip - систему управления пакетами, встроенную в Python. Эта система может устанавливать библиотеки в среду для каждого пользователя отдельно, однако конкретному пользователю может понадобиться поработать с несколькими проектами, которые, в свою очередь, будут требовать различные библиотеки для работы. Более того, для разных проектов может понадобиться одна и та же библиотека, но разных версий.

Чтобы интерпретатор Python не импортировал одни и те же библиотеки из одного и того же окружения для каждого проекта, были придуманы виртуальные окружения, которые содержат в себе копии интерпретатора и pip'а.

Акутальный модуль для создания и установки виртуальных окружений называется **venv**.

## 3. Requirements.txt

Файл requirements.txt традиционно создается при написании кода. В этом файле хранятся названия библиотек, которые используются в конкретном проекте, и используемые их версии. Данный файл может пригодиться, если потребуется запустить код в другой виртуальной среде (хотя для этого есть виртуальные окружения) или на другой вычислительной машине.

Чтобы не выискивать все библиотеки и не устанавливать их каждый по одному и каждый раз, обладая кодом и файлом requirements.txt достаточно при имеющемся pip'e запустить следующую строчку кода:

```
pip install -r requirements.txt
```

Опция **-r** нужна для того, чтобы установить библиотеку **из файла**. Без этой опции pip будет пытаться установить несуществующую библиотеку под названием "requirements.txt".

Чтобы создать requirements.txt, нужно воспользоваться командой freeze:

```
pip freeze > requirements.txt
```

## 4. Списковые включения. Основы

List comprehensions - механизм, позволяющий уместить порой многострочные конструкции, состоящие из циклов **for** и условных конструкций **if / else**, в одну строчку.

```
Y = [ ... for i in X if ... ]
```

Пример 1: операция над каждым элементом списка:

```
lst = [1, 2, 4]
cubes = [x**3 for x in lst]
```

Пример 2: фильтрация элементов через условие

```
lst = [1, 2, 4]
cubes = [x**3 for x in lst if x < 3]
```

Пример 3: фильтрация элементов через несколько условий:

```
lst = [1, 2, 4, 7]
cubes = [x**3 for x in lst if x < 3 if x < 3 if x % 2 == 0]
```

Пример 4: вложенное условие

```
lst = [1, 2, 4]
cubes = [x**3 if x < 3 else x**2 for x in lst]
```

Как видим, с добавлением новых условий цикл не дублируется для каждого if/else, а уходит в конец спискового включения.

P.s. Списковые включения, конечно, удобны для простых задач или небольших вычислений, но все сводить к списковым включениям, конечно же, не стоит.

## 5. Numpy, Pandas

Numpy и Pandas - основные библиотеки, с которыми нужно познакомиться при начале работы с Python.

### Numpy

Numpy - библиотека, которую используют как для реализации вычислений линейной алгебры, так и для упрощения многих других математических операций в рамках написания кода. В основном используется для работы с векторами и матрицами.

Numpy является open-source библиотекой, которая написана на компилируемых языках C и Fortran, что позволяет выполнять вычисления довольно быстро.

Основные методы библиотеки (далее - np):

### 1. Инициализация массива

```
m = np.array([1, 2, 3])
```

Через второй аргумент можно задать тип элементов массива:

```
m = np.array([1, 2, 3], float)
```

### 2. Инициализация матрицы

```
m = np.array([[1, 2, 3], [4, 5, 6], [7, 8, 9]])
```
P.s. Добавляются еще одни квадратные скобки, которые ставятся сразу после и перед скобками.

### 3. Возвращение суммы элементов массива

```
m = np.array([1, 2, 3])
print(m.sum())
```

### 4. Возвращение среднего арифметического

```
m = np.array([1, 2, 3])
print(m.mean())
```

### 5. Возвращение минимального/максимального элемента массива

```
m = np.array([1, 2, 3])
print(m.min())
print(m.max())
```

### 6. Возвращение индекса минимального/максимального элемента массива

```
m = np.array([1, 2, 3])
print(m.argmin())
print(m.argmax())
```

### 7. Создание массива из нулей

```
np.zeros((n, m), int)
```

n - количество строк  
m - количество столбцов
int - тип данных элементов массива (по умолчанию - float)

### 8. Создание массива из единиц

```
np.ones((n, m), int)
```

n - количество строк  
m - количество столбцов
int - тип данных элементов массива (по умолчанию - float)

### 9. Копия массива

```
b = np.copy(a)
```

### 10. Единичная матрица размера n

```
np.eye(n)
```

### 11. Перемножение матриц

```
print(np.dot(a, b))
print(a.dot(b))
print(a @ b)
```

P.s. Умножать матрицы можно только тогда, когда количество строк первой матрицы равно количеству столбцов второй матрицы.

### 12. Произведение всех элементов матрицы $\prod$ 

```
a = np.array([[10, 10], [20, 5]])
print(np.prod(a))
print(a.prod())
```

### 13. Сумма всех элементов матрицы $\sum$ 

```
a = np.array([[10, 10], [20, 5]])
print(np.sum(a))
print(a.sum())
```
### 14. Математические константы $\pi$ и $e$

```
np.pi  
np.e
```

### 15. Дисперсия и стандартное отклонение

```
a = np.array([1, 2, 3, 4, 5, 6, 10])
print(a.var())
print(a.std())
```

P.s. Стандартное отклонение есть корень из дисперсии.

### 16. Тригонометрические функции

Функции принимают радианы в качестве аргументов:

```
print(np.sin(np.pi))
print(np.cos(np.pi))
print(np.tan(np.pi))
```

### 17. Взятие квадратного корня

Корень можно брать как от одного числа, так и от целого массива:

```
print(np.sqrt([1, 2, 4, 16]))
print(np.sqrt(25))
```

### 18. Создание списка уникальных элементов

Под уникальными понимаются определенные элементы, исключая их повторения. Иными словами соответствующая функция убирает из массива повторяющиеся переменные:

```
a = np.array([1, 1, 2, 2, 5])
print(np.unique(b))
```

### 19. Сортировка массивов

Сортировка выполняется построчно, однако можно сделать ее и по столбцам. Для этого через запятую нужно указать аргумент 0:

```
a = np.array([[2, 3],[1, 4]])
print(np.sort(a))
print(np.sort(a, 0))
```

### 20. Сортировка индексов массивов

Чтобы не потерять значения прежних индексов элементов после сортировки массива, можно использовать следующую функцию:

a = np.array([[2, 3],[1, 4]])
print(np.argsort(a))
print(np.argsort(a, 0))

### 21. Возвращение массива с заданным шагом

Например, если нам будет нужен массив, состоящий из чисел от 1 до 100 с шагом 9 (1, 10, 19, 28, ...), то для этого можно использовать функцию:

```
print(np.arange(1, 101, 9))
```

Заметим, что крайнее число в массиве не включается в него при попадании под требуемые условия, поэтому иногда правую границу нужно изменить на +1

## 6. Списковые срезы 
